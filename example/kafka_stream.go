// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package example

import (
	"log"
	"sync"
)

// Topic computes on a stream of key (KafkaKey) value (KafkaValue) messages.
type Topic struct {
	ch       <-chan KafkaMsg
	commitCh <-chan interface{}
}

// KafkaMsg is a key value pair send through the computation graph.
type KafkaMsg struct {
	Key   KafkaKey
	Value KafkaValue
}

// Branch splits the stream into count new branches. Idx selects routes messages between the streams.
func (s Topic) Branch(count int, idx func(m KafkaMsg) int) []Topic {
	chs := make([]chan KafkaMsg, count)
	commitChs := make([]chan interface{}, count)
	streams := make([]Topic, count)

	for i := 0; i < count; i++ {
		chs[i] = make(chan KafkaMsg, cap(s.ch))
		commitChs[i] = make(chan interface{}, 1)
		streams[i] = Topic{
			ch:       chs[i],
			commitCh: commitChs[i],
		}
	}

	go func() {
		for {
			select {
			case msg := <-s.ch:
				chs[idx(msg)] <- msg

			case _, ok := <-s.commitCh:
				for len(s.ch) > 0 {
					msg := <-s.ch
					chs[idx(msg)] <- msg
				}

				for i := 0; i < count; i++ {
					commitChs[i] <- struct{}{}
				}

				if !ok {
					for i := 0; i < count; i++ {
						close(chs[i])
						close(commitChs[i])
						return
					}
				}
			}
		}
	}()

	return streams
}

// Filter keeps the messages with f(message) == True.
func (s Topic) Filter(f func(m KafkaMsg) bool) Topic {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		if f(msg) {
			ch <- msg
		}
	}

	return s.Process(task)
}

// InverseFilter keeps the messages with f(message) == False.
func (s Topic) InverseFilter(f func(m KafkaMsg) bool) Topic {
	inverse := func(m KafkaMsg) bool {
		return !f(m)
	}
	return s.Filter(inverse)
}

// FlatMap creates 0-N messages per message.
func (s Topic) FlatMap(f func(m KafkaMsg, e func(KafkaMsg))) Topic {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		e := func(m KafkaMsg) {
			ch <- m
		}

		f(msg, e)
	}

	return s.Process(task)
}

// FlatMapValues creates 0-N messages per message while keeping the key.
func (s Topic) FlatMapValues(f func(v KafkaValue, e func(v KafkaValue))) Topic {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		e := func(v KafkaValue) {
			m := KafkaMsg{
				Key:   msg.Key,
				Value: v,
			}
			ch <- m
		}

		f(msg.Value, e)
	}

	return s.Process(task)
}

// Foreach executes f per messages. The function is terminal and blocks until completion.
func (s Topic) Foreach(f func(KafkaMsg)) {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		f(msg)
	}

	stream := s.Process(task)

	for range stream.commitCh {
	}
}

// Map uses m to compute a new message per message.
func (s Topic) Map(m func(m KafkaMsg) KafkaMsg) Topic {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		ch <- m(msg)
	}

	return s.Process(task)
}

// MapValues uses m to compute new values for each message.
func (s Topic) MapValues(m func(m KafkaValue) KafkaValue) Topic {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		msg.Value = m(msg.Value)
		ch <- msg
	}

	return s.Process(task)
}

// Merge combines multiple streams into one.
func (s Topic) Merge(ss ...Topic) Topic {
	ch := make(chan KafkaMsg, cap(s.ch))
	commitCh := make(chan interface{}, 1)
	streamsCount := len(ss) + 1
	internalCommitCh := make(chan interface{}, streamsCount)
	stream := Topic{
		ch:       ch,
		commitCh: commitCh,
	}
	wg := sync.WaitGroup{}

	copy := func(s Topic) {
		for {
			select {
			case msg := <-s.ch:
				ch <- msg

			case _, ok := <-s.commitCh:
				for len(s.ch) > 0 {
					msg := <-s.ch
					ch <- msg
				}
				internalCommitCh <- struct{}{}

				if !ok {
					wg.Done()
					return
				}
			}
		}
	}

	wg.Add(1)
	go copy(s)
	for _, s := range ss {
		wg.Add(1)
		go copy(s)
	}

	go func() {
		wg.Wait()
		close(ch)
		close(commitCh)
		close(internalCommitCh)
	}()

	go func() {
		i := 0
		for range internalCommitCh {
			i := (i + 1) % streamsCount
			if i == 0 {
				commitCh <- struct{}{}
			}
		}
	}()

	return stream
}

// Peek executes p per message.
func (s Topic) Peek(p func(KafkaMsg)) Topic {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		p(msg)
		ch <- msg
	}

	return s.Process(task)
}

// Print logs each message to the stderr.
func (s Topic) Print() {
	s.Foreach(PrintKafkaMsg)
}

// PrintKafkaMsg prints a message to stderr.
func PrintKafkaMsg(m KafkaMsg) {
	log.Printf("%v, %v\n", m.Key, m.Value)
}

// SelectKey creates a new key per message.
func (s Topic) SelectKey(k func(m KafkaMsg) KafkaKey) Topic {
	task := func(ch chan KafkaMsg, msg KafkaMsg) {
		ch <- KafkaMsg{
			Key:   k(msg),
			Value: msg.Value,
		}
	}

	return s.Process(task)
}

// Process executes the task and creates a new stream.
func (s Topic) Process(t func(ch chan KafkaMsg, m KafkaMsg)) Topic {
	ch := make(chan KafkaMsg, cap(s.ch))
	commitCh := make(chan interface{}, 1)
	stream := Topic{
		ch:       ch,
		commitCh: commitCh,
	}

	go func() {
		for {
			select {
			case msg := <-s.ch:
				t(ch, msg)

			case _, ok := <-s.commitCh:
				for len(s.ch) > 0 {
					msg := <-s.ch
					t(ch, msg)
				}
				commitCh <- struct{}{}

				if !ok {
					close(ch)
					close(commitCh)
					return
				}
			}
		}
	}()

	return stream
}
