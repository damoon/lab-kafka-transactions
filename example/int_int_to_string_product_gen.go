// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package example

// FlatMapToStringProduct creates 0-N messages per message.
func (s IntIntStream) FlatMapToStringProduct(f func(m IntIntMsg, e func(StringProductMsg))) StringProductStream {
	task := func(ch chan StringProductMsg, msg IntIntMsg) {
		e := func(m StringProductMsg) {
			ch <- m
		}

		f(msg, e)
	}

	return s.ProcessToStringProduct(task)
}

// MapToStringProduct uses m to compute a new message per message.
func (s IntIntStream) MapToStringProduct(m func(m IntIntMsg) StringProductMsg) StringProductStream {
	task := func(ch chan StringProductMsg, msg IntIntMsg) {
		ch <- m(msg)
	}

	return s.ProcessToStringProduct(task)
}

// ProcessToStringProduct executes the task and creates a new stream.
func (s IntIntStream) ProcessToStringProduct(t func(ch chan StringProductMsg, m IntIntMsg)) StringProductStream {
	ch := make(chan StringProductMsg, cap(s.ch))
	commitCh := make(chan interface{}, 1)
	stream := StringProductStream{
		ch:       ch,
		commitCh: commitCh,
	}

	go func() {
		for {
			select {
			case msg := <-s.ch:
				t(ch, msg)

			case _, ok := <-s.commitCh:
				for len(s.ch) > 0 {
					msg := <-s.ch
					t(ch, msg)
				}
				commitCh <- struct{}{}

				if !ok {
					close(ch)
					close(commitCh)
					return
				}
			}
		}
	}()

	return stream
}
